"""
This type stub file was generated by pyright.
"""

from typing import Optional, Union
from pyiem.nws import ugc
from pyiem.wmo import WMOProduct

"""Base Class encapsulating a NWS Text Product"""
AFOSRE = ...
TIME_MOT_LOC = ...
LAT_LON_PREFIX = ...
LAT_LON = ...
WINDHAIL = ...
HAILTAG = ...
WINDTAG = ...
TORNADOTAG = ...
SPOUTTAG = ...
DAMAGETAG = ...
THREATTAG = ...
FLOOD_TAGS = ...
TORNADO = ...
RESENT = ...
EMERGENCY_RE = ...
PDS_RE = ...
SQUALLTAG = ...
SQUALLIMPACTTAG = ...
EF_RE = ...
ATTN_WFO = ...
ATTN_RFC = ...
def damage_survey_pns(prod, data): # -> tuple[str, str]:
    """Glean out things, hopefully."""
    ...

def checker(lon, lat, strdata): # -> tuple[Any, Any]:
    """make sure our values are within physical bounds"""
    ...

def str2polygon(strdata): # -> Polygon | None:
    """Convert some string data into a polygon"""
    ...

def qc_is_emergency(seg): # -> None:
    """Belt + Suspenders check that this segment is an emergency."""
    ...

class TextProductSegment:
    """A segment of a Text Product"""
    def __init__(self, text, tp: TextProduct) -> None:
        """Constructor"""
        ...
    
    def get_ugcs_tuple(self): # -> tuple[str, ...]:
        """Helper to return a tuple useful for SQL."""
        ...
    
    def get_ugcs_list(self): # -> list[str]:
        """Helper to return a list useful for SQL."""
        ...
    
    def get_hvtec_nwsli(self): # -> None:
        """Return the first hvtec NWSLI entry, if it exists"""
        ...
    
    def get_hvtec_cause(self): # -> None:
        """Return the first hvtec cause entry, if it exists"""
        ...
    
    def get_hvtec_severity(self): # -> None:
        """Return the first hvtec severity entry, if it exists"""
        ...
    
    def get_hvtec_record(self): # -> None:
        """Return the first hvtec record entry, if it exists"""
        ...
    
    def svs_search(self): # -> str:
        """Special search the product for special text"""
        ...
    
    def process_bullets(self): # -> list[str]:
        """Figure out the bulleted segments"""
        ...
    
    def process_tags(self): # -> None:
        """Find various tags in this segment"""
        ...
    
    def special_tags_to_text(self): # -> LiteralString | Literal['']:
        """
        Convert the special tags into a nice text
        """
        ...
    
    def process_latlon(self): # -> Polygon | None:
        """Parse the segment looking for the 'standard' LAT...LON encoding"""
        ...
    
    def process_time_mot_loc(self): # -> None:
        """Try to parse the TIME...MOT...LOC"""
        ...
    
    def parse_headlines(self): # -> list[Any]:
        """Find headlines in this segment"""
        ...
    
    def get_affected_wfos(self) -> list[str]:
        """Based on the ugc_provider, figure out which WFOs are impacted by
        this product segment"""
        ...
    


class TextProduct(WMOProduct):
    """class representing a NWS Text Product"""
    def __init__(self, text, utcnow=..., ugc_provider: Optional[Union[ugc.UGCProvider, dict]] = ..., nwsli_provider=..., parse_segments=...) -> None:
        """
        Constructor
        @param text string single text product
        @param utcnow used to compute offsets for when this product my be valid
        @param ugc_provider dict or UGCProvider instance
        @param parse_segments should the segments be parsed as well? True
        """
        ...
    
    def suv_iter(self): # -> Generator[tuple[Any, Any, Any], Any, None]:
        """Yield [(segment, ugcs, vtec)] combos found in product."""
        ...
    
    def is_resent(self):
        """Check to see if this product is a ...RESENT product"""
        ...
    
    def is_correction(self): # -> bool:
        """Is this product a correction?

        Sadly, this is not as easy as it should be.  It turns out that some
        products do not have a proper correction mechanism, so offices will
        just brute force in a note into the MND header.  So we have to do
        some further checking...

        Returns:
          bool: Is this product a correction?
        """
        ...
    
    def parse_attn_rfc(self): # -> list[Any]:
        """Figure out which RFCs this product is seeking attention"""
        ...
    
    def parse_attn_wfo(self): # -> list[Any]:
        """Figure out which WFOs this product is seeking attention"""
        ...
    
    def get_channels(self): # -> list[Any | str | None]:
        """Return a list of channels"""
        ...
    
    def get_nicedate(self): # -> str:
        """Nicely format the issuance time of this product"""
        ...
    
    def get_main_headline(self, default=...): # -> str:
        """Return a string for the main headline, if it exists"""
        ...
    
    def get_jabbers(self, uri, _uri2=...): # -> list[tuple[str, str, dict[str, Any | str]]]:
        """Return a tuple of jabber messages [(plain, html, xtra_dict)]

        Args:
          uri (str): the base URI to use to construct links

        Returns:
          [(str, str, dict)]
        """
        ...
    
    def get_signature(self) -> Optional[str]:
        """Attempt to glean the free form text that is a signature."""
        ...
    
    def parse_segments(self): # -> None:
        """Split the product by its $$"""
        ...
    
    def get_product_id(self): # -> str:
        """Get an identifier of this product used by the IEM"""
        ...
    
    def get_affected_wfos(self): # -> list[Any]:
        """Based on the ugc_provider, figure out which WFOs are impacted by
        this product"""
        ...
    
    def parse_afos(self): # -> None:
        """Figure out what the AFOS PIL is"""
        ...
    


