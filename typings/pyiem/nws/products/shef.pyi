"""
This type stub file was generated by pyright.
"""

from typing import List
from pyiem.models.shef import SHEFElement
from pyiem.nws.product import TextProduct

"""Standard Hydrological Exchange Format (SHEF).

https://www.weather.gov/media/mdl/SHEF_CodeManual_5July2012.pdf

Formats
-------
.A - single station, multiple parameter
.B - multiple station, multiple parameter, header driven
.E - single station, single parameter, evenly spaced time series

Implementation Notes
--------------------

- The IEM uses a nomenclature of 0.0001 float value to represent Trace values,
not the 0.001 that SHEF does.
- When `DH` is blank or `DHM`, this generates a SHEFElement with a None valid
attribute.  This is ambiguous behavior to consider further.

TODO List
---------
 - 4.4.4 DIE special end-of-month specifier
 - 5.1.4 how to handle repeated data
 - Handle when R is being specified in the AR BR ER
 - 5.1.6 revision of a missing value
 - 5.2.1 DR codes, DRE end of month
 - Table 9a D codes
 - 4.4.1 ugly time logic and DN support
 - Handle UQ variable SSS.SDDD
 - Handle UR (tens of degrees)

"""
TIMEZONES = ...
PAIRED_PHYSICAL_CODES = ...
TRACE_PHYSICAL_CODES = ...
RETAINED_COMMENT_RE = ...
NUMBER_RE = ...
MISSING_VALUES = ...
def parse_d_wrapper(func): # -> Callable[..., Any]:
    """Catch exceptions."""
    ...

def make_date(text, now=...): # -> date:
    """Make the text date unambiguous."""
    ...

def parse_dc(text, basevalid): # -> datetime:
    """Convert the DC element into a timestamp."""
    ...

def parse_dy(text, basevalid): # -> datetime:
    """Convert the DY element into a timestamp."""
    ...

def datetime24(dt, replacements): # -> datetime:
    """Handle the junkiness that is a `24` hour."""
    ...

@parse_d_wrapper
def parse_dh(text, valid): # -> datetime:
    """Account for the craziness of the DH value."""
    ...

def parse_station_valid(text, utcnow): # -> tuple[Any, datetime, datetime, list[Any]]:
    """Parse the first token found in a SHEF observation.

    Args:
      text (str): the first part of the string
      utcnow (datetime): The default time.

    Returns
    -------
      str, datetime, datetime, list
    """
    ...

def process_di(text): # -> timedelta:
    """Convert a DI value into an interval."""
    ...

@parse_d_wrapper
def parse_dm(text, valid): # -> datetime:
    """Handle the DM one."""
    ...

@parse_d_wrapper
def parse_dd(text, valid): # -> datetime:
    """Handle the DD one."""
    ...

@parse_d_wrapper
def parse_dt(text, valid): # -> datetime:
    """Handle the DD one."""
    ...

def process_modifiers(text, diction, basevalid): # -> bool:
    """Apply modifications based on what the token is telling us.

    Args:
      text (str): Potential new information.
      diction (SHEFElement): our current elemenet definition
      basevalid (datetime): the base valid in case of relative time.

    Returns
    -------
      bool for if this text was handled.
    """
    ...

def process_message_e(prod, message) -> List[SHEFElement]:
    """Process a text string in E SHEF format.

    Args:
      prod (SHEFProduct): the product we are working on.
      message (str): The string to parse.

    Returns
    -------
      List[SHEFElement]
    """
    ...

def strip_comments(line): # -> Literal['']:
    """Remove comments."""
    ...

def clean_b_headerline(text): # -> str:
    """Account for invalid encoding. SIGH."""
    ...

def process_message_b(prod, message) -> List[SHEFElement]:
    """Convert the message into an object."""
    ...

def slash_tokenize(message): # -> list[Any]:
    """Carefully discover tokens."""
    ...

def process_message_a(prod, message) -> List[SHEFElement]:
    """Convert the message into an object."""
    ...

def process_messages(func, prod, messages) -> int:
    """Safe frontend to do message processing."""
    ...

def parse_A(prod) -> int:
    """Parse A format SHEF data."""
    ...

def parse_B(prod) -> int:
    """Parse B format SHEF data."""
    ...

def parse_E(prod) -> int:
    """Parse E format SHEF data."""
    ...

def compute_num_value(element) -> bool:
    """Attempt to make this into a float."""
    ...

class SHEFProduct(TextProduct):
    """A single text product containing SHEF encoded data."""
    def __init__(self, text, utcnow=..., ugc_provider=..., nwsli_provider=...) -> None:
        """Construct."""
        ...
    


def parser(text, utcnow=..., ugc_provider=..., nwsli_provider=...): # -> SHEFProduct:
    """Parser."""
    ...

